5层网络模型

应用层
HTTP协议在应用层里，构建在传输层之上，没有规定传输层必须使用TCP协议

传输层
最流行的协议包括TCP协议、UDP协议，向用户提供可靠的端到端的服务

网络层
定义了节点之间的逻辑链路

数据链路层
定义了在单个链路上如何传输数据，这些协议与被讨论的介质有关

物理层
定义物理设备如何传输数据

HyperText Transfer Protocol 超文本传输协议

HTTP发展历史

HTTP/0.9
只接受GET请求方法
没有在通讯中指出HTTP协议版本号
不支持请求头
服务器发送完数据后，立马关闭通讯连接，例关闭TCP连接

HTTP/1.0
增加很多命令，例POST,OPTIONS,HEAD,PUT,DELETE
增加响应状态码status code
在通讯中增加指定HTTP版本号和请求头
增加多字符集支持
增加缓存，权限等内容

HTTP/1.1
增加持久连接，且默认采用
增加管道方式，同时发送多个请求，串行处理请求，必须等待上一个请求得到响应后，才执行下一个请求
请求头增加host行，同一台物理服务器，可以运行多个web服务，通过host的值来设别，请求的是哪个web服务

HTTP/2.0
所有数据以二进制传输
管道方式优化，可并发处理多个请求
头信息压缩
服务器推送，需要配置，未收到请求，就把资源推送给浏览器


HTTP三次握手
第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
为了防止网络的延迟，导致服务器端一直等待而浪费资源

三次握手实例
IP 192.168.1.116.3337 > 192.168.1.123.7788: SYN         seq_number:3626544836
IP 192.168.1.123.7788 > 192.168.1.116.3337: SYN   ACK   seq_number:1739326486   ack_number:3626544837
IP 192.168.1.116.3337 > 192.168.1.123.7788: ACK                                 ack_number:1739326487

第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;

第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;

第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。

URI uniform resource identifier
统一资源标识符
用于标识某一互联网资源名称的字符串
是 URL 和 URN 的统称

URL uniform resource locator
统一资源定位符

URN  uniform resource name
永久统一资源定位符


请求报文
请求行 （例如GET /images/logo.gif HTTP/1.1 -- 请求方法 资源路径 HTTP协议版本）
请求头 （例如Accept-Language: en , Accept-Encoding: gzip, deflate）
空行！！必须有
消息体

响应报文
响应行 （例如HTTP/1.1 200 OK -- HTTP协议版本 状态码 描述状态的短语）
响应头 （例如Accept-Language: en , Accept-Encoding: gzip, deflate）
空行！！必须有
消息体

状态码
1XX -- 信息，请求已被服务器接收，需要请求者继续执行操作
2XX -- 成功，操作被成功接受处理
3XX -- 重定向，需要进一步操作已完成请求
4XX -- 客服端错误，请求包含语法错误或无法完成请求
5XX -- 服务器错误，服务器在处理请求的过程中发生了错误


Access-Control-Allow-Origin
若浏览器发现跨域，但响应头没有包含此字段，就会报错。
此字段的值要么是请求时Origin字段的值，要么是一个*

cache-control
用于在HTTP请求和响应的消息头中通过指令来实现缓存机制。缓存指令是单向的，意味着在请求设置的指令，在响应中不一定包含相同指令
指令不区分大小写，指令间用逗号分隔
--- 可缓存性 ---
public   表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存
private  表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）
no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则使用缓存
--- 到期 ---
max-age=<seconds>  设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)
s-maxage=<seconds> 仅适用与共享缓存（代理服务器），会覆盖max-age
max-stale[=<seconds>] 发出请求方设置项，表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间(单位秒)，表示过期资源的最大过期时间，超过后不使用缓存
--- 重新验证/加载 ---
must-revalidate 使用缓存前必须验证，且不可使用过期缓存
proxy-revalidate 与must-revalidate作用相同，仅适用与代理服务器
--- 其他 ---
no-store 直接禁止浏览器以及所有代理服务器缓存任何响应
no-transform 不得对资源进行转换或转变

存在cache-control头且需要进行资源验证需要以下头进行验证
last-modified 
服务器认定的上次修改时间，存在响应头中，第二次请求资源时，会在请求头中带上if-modified-since，用于询问服务器文件在此时间后，是否修改过
etag
是资源的特定版本的标识符，数据签名，存在响应头中，第二次请求资源时，会在请求头中带上if-match或者if-none-match头，它们的值是服务器带来的etag的值，服务器对比资源的签名，判断是否适用缓存
expires
响应头中带有的标识缓存过期时间的头，返回的时间是服务器时间，如果客户端的时间与服务器的时间相差很大，就会存在很大误差。在过期时间前，客户端不会发起请求去获取数据，直接使用缓存中数据。如果存在cache-control:max-age会被替代。


保持连接
HTTP/1.1版本新增，默认开启，头字段为connection:keep-alive，关闭设置connection:close
请求发送方式是串行的，一个连接中每个请求必须等待收到响应后才能发送下一个请求
浏览器一般会默认开启多个连接，然后再根据每个连接的状态发送请求


HTTPS
加密传输数据
http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html